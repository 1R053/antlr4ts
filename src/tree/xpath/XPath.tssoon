// ConvertTo-TS run at 2016-10-04T11:26:46.4373888-07:00

/**
 * Represent a subset of XPath XML path syntax for use in identifying nodes in
 * parse trees.
 *
 * <p>
 * Split path into words and separators {@code /} and {@code //} via ANTLR
 * itself then walk path elements from left to right. At each separator-word
 * pair, find set of nodes. Next stage uses those as work list.</p>
 *
 * <p>
 * The basic interface is
 * {@link XPath#findAll ParseTree.findAll}{@code (tree, pathString, parser)}.
 * But that is just shorthand for:</p>
 *
 * <pre>
 * {@link XPath} p = new {@link XPath#XPath XPath}(parser, pathString);
 * return p.{@link #evaluate evaluate}(tree);
 * </pre>
 *
 * <p>
 * See {@code org.antlr.v4.test.TestXPath} for descriptions. In short, this
 * allows operators:</p>
 *
 * <dl>
 * <dt>/</dt> <dd>root</dd>
 * <dt>//</dt> <dd>anywhere</dd>
 * <dt>!</dt> <dd>invert; this must appear directly after root or anywhere
 * operator</dd>
 * </dl>
 *
 * <p>
 * and path elements:</p>
 *
 * <dl>
 * <dt>ID</dt> <dd>token name</dd>
 * <dt>'string'</dt> <dd>any string literal token from the grammar</dd>
 * <dt>expr</dt> <dd>rule name</dd>
 * <dt>*</dt> <dd>wildcard matching any node</dd>
 * </dl>
 *
 * <p>
 * Whitespace is not allowed.</p>
 */
export class XPath {
	static WILDCARD: string =  "*"; // word not operator/separator
	static NOT: string =  "!"; 	   // word for invert operator

	protected path: string; 
	protected elements: XPathElement[]; 
	protected parser: Parser; 

	 constructor(parser: Parser, path: string)  {
		this.parser = parser;
		this.path = path;
		elements = split(path);
//		System.out.println(Arrays.toString(elements));
	}

	// TODO: check for invalid token/rule names, bad syntax

	split(path: string): XPathElement[] {
		let in: ANTLRInputStream; 
		try {
			in = new ANTLRInputStream(new StringReader(path));
		}
		catch (IOException ioe) {
			throw new IllegalArgumentException("Could not read path: "+path, ioe);
		}
		let lexer: XPathLexer =  new XPathLexer(in) {
			recover(e: LexerNoViableAltException): void { throw e;	}
		};
		lexer.removeErrorListeners();
		lexer.addErrorListener(new XPathLexerErrorListener());
		let tokenStream: CommonTokenStream =  new CommonTokenStream(lexer);
		try {
			tokenStream.fill();
		}
		catch (LexerNoViableAltException e) {
			let pos: number =  lexer.getCharPositionInLine();
			let msg: string =  "Invalid tokens or characters at index "+pos+" in path '"+path+"'";
			throw new IllegalArgumentException(msg, e);
		}

		let tokens: List<Token> =  tokenStream.getTokens();
//		System.out.println("path="+path+"=>"+tokens);
		let elements: List<XPathElement> =  new ArrayList<XPathElement>();
		let n: number =  tokens.size();
		let i: number = 0;
loop:
		while ( i<n ) {
			let el: Token =  tokens.get(i);
			let next: Token =  null;
			switch ( el.getType() ) {
				case XPathLexer.ROOT :
				case XPathLexer.ANYWHERE :
					let anywhere: boolean =  el.getType() == XPathLexer.ANYWHERE;
					i++;
					next = tokens.get(i);
					let invert: boolean =  next.getType()==XPathLexer.BANG;
					if ( invert ) {
						i++;
						next = tokens.get(i);
					}
					let pathElement: XPathElement =  getXPathElement(next, anywhere);
					pathElement.invert = invert;
					elements.add(pathElement);
					i++;
					break;

				case XPathLexer.TOKEN_REF :
				case XPathLexer.RULE_REF :
				case XPathLexer.WILDCARD :
					elements.add( getXPathElement(el, false) );
					i++;
					break;

				case Token.EOF :
					break loop;

				default :
					throw new IllegalArgumentException("Unknowth path element "+el);
			}
		}
		return elements.toArray(new XPathElement[0]);
	}

	/**
	 * Convert word like {@code *} or {@code ID} or {@code expr} to a path
	 * element. {@code anywhere} is {@code true} if {@code //} precedes the
	 * word.
	 */
	protected getXPathElement(wordToken: Token, anywhere: boolean): XPathElement {
		if ( wordToken.getType()==Token.EOF ) {
			throw new IllegalArgumentException("Missing path element at end of path");
		}
		let word: string =  wordToken.getText();
		let ttype: number =  parser.getTokenType(word);
		let ruleIndex: number =  parser.getRuleIndex(word);
		switch ( wordToken.getType() ) {
			case XPathLexer.WILDCARD :
				return anywhere ?
					XPathWildcardAnywhereElement(): new :
					XPathWildcardElement(): new;
			case XPathLexer.TOKEN_REF :
			case XPathLexer.STRING :
				if ( ttype==Token.INVALID_TYPE ) {
					throw new IllegalArgumentException(word+
													   " at index "+
													   wordToken.getStartIndex()+
													   " isn't a valid token name");
				}
				return anywhere ?
					XPathTokenAnywhereElement(word,  ttype): new :
					XPathTokenElement(word,  ttype): new;
			default :
				if ( ruleIndex==-1 ) {
					throw new IllegalArgumentException(word+
													   " at index "+
													   wordToken.getStartIndex()+
													   " isn't a valid rule name");
				}
				return anywhere ?
					XPathRuleAnywhereElement(word,  ruleIndex): new :
					XPathRuleElement(word,  ruleIndex): new;
		}
	}

	static findAll(tree: ParseTree, xpath: string, parser: Parser): Collection<ParseTree> {
		let p: XPath =  new XPath(parser, xpath);
		return p.evaluate(tree);
	}

	/**
	 * Return a list of all nodes starting at {@code t} as root that satisfy the
	 * path. The root {@code /} is relative to the node passed to
	 * {@link #evaluate}.
	 */
	evaluate(final ParseTree t): Collection<ParseTree> {
		let dummyRoot: ParserRuleContext =  new ParserRuleContext();
		dummyRoot.children = Collections.singletonList(t); // don't set t's parent.

		let work: Collection<ParseTree> =  Collections.<ParseTree>singleton(dummyRoot);

		let i: number =  0;
		while ( i < elements.length ) {
			let next: Collection<ParseTree> =  new LinkedHashSet<ParseTree>();
			for (let node of work) {
				if ( node.getChildCount()>0 ) {
					// only try to match next element if it has children
					// e.g., //func/*/stat might have a token node for which
					// we can't go looking for stat nodes.
					let matching: Collection<? extends ParseTree> =  elements[i].evaluate(node);
					next.addAll(matching);
				}
			}
			i++;
			work = next;
		}

		return work;
	}
}
