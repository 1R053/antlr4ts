/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// ConvertTo-TS run at 2016-10-04T11:26:50.1614404-07:00

export class CommonToken implements WritableToken, Serializable {
	private static serialVersionUID: number =  -6708843461296520577L;

	/**
	 * An empty {@link Tuple2} which is used as the default value of
	 * {@link #source} for tokens that do not have a source.
	 */
	protected static EMPTY_SOURCE: Tuple2<TokenSource, CharStream> = 
		Tuple.<TokenSource, CharStream>create(null, null);

	/**
	 * This is the backing field for {@link #getType} and {@link #setType}.
	 */
	protected type: number; 
	/**
	 * This is the backing field for {@link #getLine} and {@link #setLine}.
	 */
	protected line: number; 
	/**
	 * This is the backing field for {@link #getCharPositionInLine} and
	 * {@link #setCharPositionInLine}.
	 */
	protected charPositionInLine: number =  -1; // set to invalid position
	/**
	 * This is the backing field for {@link #getChannel} and
	 * {@link #setChannel}.
	 */
	protected channel: number = DEFAULT_CHANNEL;
	/**
	 * This is the backing field for {@link #getTokenSource} and
	 * {@link #getInputStream}.
	 *
	 * <p>
	 * These properties share a field to reduce the memory footprint of
	 * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from
	 * the same source and input stream share a reference to the same
	 * {@link Tuple2} containing these values.</p>
	 */
	@NotNull
	protected source: Tuple2<? extends TokenSource, CharStream>; 

	/**
	 * This is the backing field for {@link #getText} when the token text is
	 * explicitly set in the constructor or via {@link #setText}.
	 *
	 * @see #getText()
	 */
	protected text: string; 

	/**
	 * This is the backing field for {@link #getTokenIndex} and
	 * {@link #setTokenIndex}.
	 */
	protected index: number =  -1;

	/**
	 * This is the backing field for {@link #getStartIndex} and
	 * {@link #setStartIndex}.
	 */
	protected start: number; 

	/**
	 * This is the backing field for {@link #getStopIndex} and
	 * {@link #setStopIndex}.
	 */
	protected stop: number; 

	/**
	 * Constructs a new {@link CommonToken} with the specified token type.
	 *
	 * @param type The token type.
	 */
	 constructor(type: number)  {
		this.type = type;
		this.source = EMPTY_SOURCE;
	}

	 constructor1(@NotNull source: Tuple2<? extends TokenSource,CharStream>, type: number, channel: number, start: number, stop: number)  {
		this.source = source;
		this.type = type;
		this.channel = channel;
		this.start = start;
		this.stop = stop;
		if (source.getItem1() != null) {
			this.line = source.getItem1().getLine();
			this.charPositionInLine = source.getItem1().getCharPositionInLine();
		}
	}

	/**
	 * Constructs a new {@link CommonToken} with the specified token type and
	 * text.
	 *
	 * @param type The token type.
	 * @param text The text of the token.
	 */
	 constructor2(type: number, text: string)  {
		this.type = type;
		this.channel = DEFAULT_CHANNEL;
		this.text = text;
		this.source = EMPTY_SOURCE;
	}

	/**
	 * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
	 *
	 * <p>
	 * If {@code oldToken} is also a {@link CommonToken} instance, the newly
	 * constructed token will share a reference to the {@link #text} field and
	 * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
	 * be assigned the result of calling {@link #getText}, and {@link #source}
	 * will be constructed from the result of {@link Token#getTokenSource} and
	 * {@link Token#getInputStream}.</p>
	 *
	 * @param oldToken The token to copy.
	 */
	 constructor3(@NotNull oldToken: Token)  {
		type = oldToken.getType();
		line = oldToken.getLine();
		index = oldToken.getTokenIndex();
		charPositionInLine = oldToken.getCharPositionInLine();
		channel = oldToken.getChannel();
		start = oldToken.getStartIndex();
		stop = oldToken.getStopIndex();

		if (oldToken instanceof CommonToken) {
			text = ((CommonToken)oldToken).text;
			source = ((CommonToken)oldToken).source;
		}
		else {
			text = oldToken.getText();
			source = Tuple.create(oldToken.getTokenSource(), oldToken.getInputStream());
		}
	}

	@Override
	getType(): number {
		return type;
	}

	@Override
	setLine(line: number): void {
		this.line = line;
	}

	@Override
	getText(): string {
		if ( text!=null ) {
			return text;
		}

		let input: CharStream =  getInputStream();
		if ( input==null ) return null;
		let n: number =  input.size();
		if ( start<n && stop<n) {
			return input.getText(Interval.of(start,stop));
		}
		else {
			return "<EOF>";
		}
	}

	/**
	 * Explicitly set the text for this token. If {code text} is not
	 * {@code null}, then {@link #getText} will return this value rather than
	 * extracting the text from the input.
	 *
	 * @param text The explicit text of the token, or {@code null} if the text
	 * should be obtained from the input along with the start and stop indexes
	 * of the token.
	 */
	@Override
	setText(text: string): void {
		this.text = text;
	}

	@Override
	getLine(): number {
		return line;
	}

	@Override
	getCharPositionInLine(): number {
		return charPositionInLine;
	}

	@Override
	setCharPositionInLine(charPositionInLine: number): void {
		this.charPositionInLine = charPositionInLine;
	}

	@Override
	getChannel(): number {
		return channel;
	}

	@Override
	setChannel(channel: number): void {
		this.channel = channel;
	}

	@Override
	setType(type: number): void {
		this.type = type;
	}

	@Override
	getStartIndex(): number {
		return start;
	}

	setStartIndex(start: number): void {
		this.start = start;
	}

	@Override
	getStopIndex(): number {
		return stop;
	}

	setStopIndex(stop: number): void {
		this.stop = stop;
	}

	@Override
	getTokenIndex(): number {
		return index;
	}

	@Override
	setTokenIndex(index: number): void {
		this.index = index;
	}

	@Override
	getTokenSource(): TokenSource {
		return source.getItem1();
	}

	@Override
	getInputStream(): CharStream {
		return source.getItem2();
	}

	@Override
	toString(): string {
		let channelStr: string =  "";
		if ( channel>0 ) {
			channelStr=",channel="+channel;
		}
		let txt: string =  getText();
		if ( txt!=null ) {
			txt = txt.replace("\n","\\n");
			txt = txt.replace("\r","\\r");
			txt = txt.replace("\t","\\t");
		}
		else {
			txt = "<no text>";
		}
		return "[@"+getTokenIndex()+","+start+":"+stop+"='"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
	}
}
