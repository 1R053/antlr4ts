/*
 * [The "BSD license"]
 *  Copyright (c) 2013 Terence Parr
 *  Copyright (c) 2013 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00

/**
 * @since 4.3
 */
export class ProfilingATNSimulator extends ParserATNSimulator {
	protected decisions: DecisionInfo[]; 
	protected numDecisions: number; 

	protected TokenStream _input;
	protected int _startIndex;
	protected int _sllStopIndex;
	protected int _llStopIndex;

	protected currentDecision: number; 
	protected currentState: SimulatorState; 

 	/** At the point of LL failover, we record how SLL would resolve the conflict so that
	 *  we can determine whether or not a decision / input pair is context-sensitive.
	 *  If LL gives a different result than SLL's predicted alternative, we have a
	 *  context sensitivity for sure. The converse is not necessarily true, however.
	 *  It's possible that after conflict resolution chooses minimum alternatives,
	 *  SLL could get the same answer as LL. Regardless of whether or not the result indicates
	 *  an ambiguity, it is not treated as a context sensitivity because LL prediction
	 *  was not required in order to produce a correct prediction for this decision and input sequence.
	 *  It may in fact still be a context sensitivity but we don't know by looking at the
	 *  minimum alternatives for the current input.
 	 */
	protected conflictingAltResolvedBySLL: number; 

	 constructor(parser: Parser)  {
		super(parser, parser.getInterpreter().atn);
		optimize_ll1 = false;
		reportAmbiguities = true;
		numDecisions = atn.decisionToState.size();
		decisions = new DecisionInfo[numDecisions];
		for (let i=0; i<numDecisions; i++) {
			decisions[i] = new DecisionInfo(i);
		}
	}

	@Override
	adaptivePredict(input: TokenStream, decision: number, outerContext: ParserRuleContext): number {
		try {
			this._input = input;
			this._startIndex = input.index();
			// it's possible for SLL to reach a conflict state without consuming any input
			this._sllStopIndex = _startIndex - 1;
			this._llStopIndex = -1;
			this.currentDecision = decision;
			this.currentState = null;
			this.conflictingAltResolvedBySLL = ATN.INVALID_ALT_NUMBER;
			let start: number =  System.nanoTime(); // expensive but useful info
			let alt: number =  super.adaptivePredict(input, decision, outerContext);
			let stop: number =  System.nanoTime();
			decisions[decision].timeInPrediction += (stop-start);
			decisions[decision].invocations++;

			let SLL_k: number =  _sllStopIndex - _startIndex + 1;
			decisions[decision].SLL_TotalLook += SLL_k;
			decisions[decision].SLL_MinLook = decisions[decision].SLL_MinLook==0 ? SLL_k : Math.min(decisions[decision].SLL_MinLook, SLL_k);
			if ( SLL_k > decisions[decision].SLL_MaxLook ) {
				decisions[decision].SLL_MaxLook = SLL_k;
				decisions[decision].SLL_MaxLookEvent =
						LookaheadEventInfo(decision,  null,  alt,  input,  _startIndex,  _sllStopIndex,  false): new;
			}

			if (_llStopIndex >= 0) {
				let LL_k: number =  _llStopIndex - _startIndex + 1;
				decisions[decision].LL_TotalLook += LL_k;
				decisions[decision].LL_MinLook = decisions[decision].LL_MinLook==0 ? LL_k : Math.min(decisions[decision].LL_MinLook, LL_k);
				if ( LL_k > decisions[decision].LL_MaxLook ) {
					decisions[decision].LL_MaxLook = LL_k;
					decisions[decision].LL_MaxLookEvent =
							LookaheadEventInfo(decision,  null,  alt,  input,  _startIndex,  _llStopIndex,  true): new;
				}
			}

			return alt;
		}
		finally {
			this._input = null;
			this.currentDecision = -1;
		}
	}

	@Override
	protected getStartState(dfa: DFA, input: TokenStream, outerContext: ParserRuleContext, useContext: boolean): SimulatorState {
		let state: SimulatorState =  super.getStartState(dfa, input, outerContext, useContext);
		currentState = state;
		return state;
	}

	@Override
	protected computeStartState(dfa: DFA, globalContext: ParserRuleContext, useContext: boolean): SimulatorState {
		let state: SimulatorState =  super.computeStartState(dfa, globalContext, useContext);
		currentState = state;
		return state;
	}

	@Override
	protected computeReachSet(dfa: DFA, previous: SimulatorState, t: number, contextCache: PredictionContextCache): SimulatorState {
		let reachState: SimulatorState =  super.computeReachSet(dfa, previous, t, contextCache);
		if (reachState == null) {
			// no reach on current lookahead symbol. ERROR.
			decisions[currentDecision].errors.add(
				ErrorInfo(currentDecision,  previous,  _input,  _startIndex,  _input.index()): new
			);
		}

		currentState = reachState;
		return reachState;
	}

	@Override
	protected getExistingTargetState(previousD: DFAState, t: number): DFAState {
		// this method is called after each time the input position advances
		if (currentState.useContext) {
			_llStopIndex = _input.index();
		}
		else {
			_sllStopIndex = _input.index();
		}

		let existingTargetState: DFAState =  super.getExistingTargetState(previousD, t);
		if ( existingTargetState!=null ) {
			// this method is directly called by execDFA; must construct a SimulatorState
			// to represent the current state for this case
			currentState = new SimulatorState(currentState.outerContext, existingTargetState, currentState.useContext, currentState.remainingOuterContext);

			if (currentState.useContext) {
				decisions[currentDecision].LL_DFATransitions++;
			}
			else {
				decisions[currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state
			}

			if ( existingTargetState==ERROR ) {
				let state: SimulatorState =  new SimulatorState(currentState.outerContext, previousD, currentState.useContext, currentState.remainingOuterContext);
				decisions[currentDecision].errors.add(
					ErrorInfo(currentDecision,  state,  _input,  _startIndex,  _input.index()): new
				);
			}
		}

		return existingTargetState;
	}

	@Override
	protected computeTargetState(dfa: DFA, s: DFAState, remainingGlobalContext: ParserRuleContext, t: number, useContext: boolean, contextCache: PredictionContextCache): Tuple2<DFAState, ParserRuleContext> {
		let targetState: Tuple2<DFAState, ParserRuleContext> =  super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);

		if (useContext) {
			decisions[currentDecision].LL_ATNTransitions++;
		}
		else {
			decisions[currentDecision].SLL_ATNTransitions++;
		}

		return targetState;
	}

	@Override
	protected evalSemanticContext(pred: SemanticContext, parserCallStack: ParserRuleContext, alt: number): boolean {
		let result: boolean =  super.evalSemanticContext(pred, parserCallStack, alt);
		if (!(pred instanceof SemanticContext.PrecedencePredicate)) {
			let fullContext: boolean =  _llStopIndex >= 0;
			let stopIndex: number =  fullContext ? _llStopIndex : _sllStopIndex;
			decisions[currentDecision].predicateEvals.add(
				PredicateEvalInfo(currentState,  currentDecision,  _input,  _startIndex,  stopIndex,  pred,  result,  alt): new
			);
		}

		return result;
	}

	@Override
	protected reportContextSensitivity(dfa: DFA, prediction: number, acceptState: SimulatorState, startIndex: number, stopIndex: number): void {
		if ( prediction != conflictingAltResolvedBySLL ) {
			decisions[currentDecision].contextSensitivities.add(
				ContextSensitivityInfo(currentDecision,  acceptState,  _input,  startIndex,  stopIndex): new
			);
		}
		super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
	}

	@Override
	protected reportAttemptingFullContext(dfa: DFA, conflictingAlts: BitSet, conflictState: SimulatorState, startIndex: number, stopIndex: number): void {
		if ( conflictingAlts!=null ) {
			conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
		}
		else {
			conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
		}
		decisions[currentDecision].LL_Fallback++;
		super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
	}

	@Override
	protected reportAmbiguity(@NotNull dfa: DFA, D: DFAState, startIndex: number, stopIndex: number, exact: boolean, @NotNull ambigAlts: BitSet, @NotNull configs: ATNConfigSet): void {
		let prediction: number; 
		if ( ambigAlts!=null ) {
			prediction = ambigAlts.nextSetBit(0);
		}
		else {
			prediction = configs.getRepresentedAlternatives().nextSetBit(0);
		}
		if ( conflictingAltResolvedBySLL != ATN.INVALID_ALT_NUMBER && prediction != conflictingAltResolvedBySLL ) {
			// Even though this is an ambiguity we are reporting, we can
			// still detect some context sensitivities.  Both SLL and LL
			// are showing a conflict, hence an ambiguity, but if they resolve
			// to different minimum alternatives we have also identified a
			// context sensitivity.
			decisions[currentDecision].contextSensitivities.add(
					ContextSensitivityInfo(currentDecision,  currentState,  _input,  startIndex,  stopIndex): new
			);
		}
		decisions[currentDecision].ambiguities.add(
			AmbiguityInfo(currentDecision,  currentState,  ambigAlts,  _input,  startIndex,  stopIndex): new
		);
		super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
	}

	// ---------------------------------------------------------------------

	getDecisionInfo(): DecisionInfo[] {
		return decisions;
	}

	getCurrentState(): SimulatorState {
		return currentState;
	}
}
