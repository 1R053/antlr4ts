/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:25.5488013-07:00

/**
 *
 * @author Sam Harwell
 */
export class ATNConfigSet implements Set<ATNConfig> {

	/**
	 * This maps (state, alt) -> merged {@link ATNConfig}. The key does not account for
	 * the {@link ATNConfig#getSemanticContext} of the value, which is only a problem if a single
	 * {@code ATNConfigSet} contains two configs with the same state and alternative
	 * but different semantic contexts. When this case arises, the first config
	 * added to this map stays, and the remaining configs are placed in {@link #unmerged}.
	 * <p>
	 * This map is only used for optimizing the process of adding configs to the set,
	 * and is {@code null} for read-only sets stored in the DFA.
	 */
	private mergedConfigs: HashMap<number, ATNConfig>; 
	/**
	 * This is an "overflow" list holding configs which cannot be merged with one
	 * of the configs in {@link #mergedConfigs} but have a colliding key. This
	 * occurs when two configs in the set have the same state and alternative but
	 * different semantic contexts.
	 * <p>
	 * This list is only used for optimizing the process of adding configs to the set,
	 * and is {@code null} for read-only sets stored in the DFA.
	 */
	private unmerged: ArrayList<ATNConfig>; 
	/**
	 * This is a list of all configs in this set.
	 */
	private configs: ArrayList<ATNConfig>; 

	private uniqueAlt: number; 
	private conflictInfo: ConflictInfo; 
	// Used in parser and lexer. In lexer, it indicates we hit a pred
	// while computing a closure operation.  Don't make a DFA state from this.
	private hasSemanticContext: boolean; 
	private dipsIntoOuterContext: boolean; 
	/**
	 * When {@code true}, this config set represents configurations where the entire
	 * outer context has been consumed by the ATN interpreter. This prevents the
	 * {@link ParserATNSimulator#closure} from pursuing the global FOLLOW when a
	 * rule stop state is reached with an empty prediction context.
	 * <p>
	 * Note: {@code outermostConfigSet} and {@link #dipsIntoOuterContext} should never
	 * be true at the same time.
	 */
	private outermostConfigSet: boolean; 

	private cachedHashCode: number =  -1;

	 constructor()  {
		this.mergedConfigs = new HashMap<Long, ATNConfig>();
		this.unmerged = new ArrayList<ATNConfig>();
		this.configs = new ArrayList<ATNConfig>();

		this.uniqueAlt = ATN.INVALID_ALT_NUMBER;
	}

	@SuppressWarnings("unchecked")
	 constructor1(set: ATNConfigSet, readonly: boolean)  {
		if (readonly) {
			this.mergedConfigs = null;
			this.unmerged = null;
		} else if (!set.isReadOnly()) {
			this.mergedConfigs = (HashMap<Long, ATNConfig>)set.mergedConfigs.clone();
			this.unmerged = (ArrayList<ATNConfig>)set.unmerged.clone();
		} else {
			this.mergedConfigs = new HashMap<Long, ATNConfig>(set.configs.size());
			this.unmerged = new ArrayList<ATNConfig>();
		}

		this.configs = (ArrayList<ATNConfig>)set.configs.clone();

		this.dipsIntoOuterContext = set.dipsIntoOuterContext;
		this.hasSemanticContext = set.hasSemanticContext;
		this.outermostConfigSet = set.outermostConfigSet;

		if (readonly || !set.isReadOnly()) {
			this.uniqueAlt = set.uniqueAlt;
			this.conflictInfo = set.conflictInfo;
		}

		// if (!readonly && set.isReadOnly()) -> addAll is called from clone()
	}

	/**
	 * Get the set of all alternatives represented by configurations in this
	 * set.
	 */
	@NotNull
	getRepresentedAlternatives(): BitSet {
		if (conflictInfo != null) {
			return (BitSet)conflictInfo.getConflictedAlts().clone();
		}

		let alts: BitSet =  new BitSet();
		for (let config of this) {
			alts.set(config.getAlt());
		}

		return alts;
	}

	isReadOnly(): boolean {
		return mergedConfigs == null;
	}

	isOutermostConfigSet(): boolean {
		return outermostConfigSet;
	}

	setOutermostConfigSet(outermostConfigSet: boolean): void {
		if (this.outermostConfigSet && !outermostConfigSet) {
			throw new IllegalStateException();
		}

		assert(!outermostConfigSet || !dipsIntoOuterContext);
		this.outermostConfigSet = outermostConfigSet;
	}

	getStates(): Set<ATNState> {
		let states: Set<ATNState> =  new HashSet<ATNState>();
		for (let c of this.configs) {
			states.add(c.getState());
		}

		return states;
	}

	optimizeConfigs(interpreter: ATNSimulator): void {
		if (configs.isEmpty()) {
			return;
		}

		for (let i = 0; i < configs.size(); i++) {
			let config: ATNConfig =  configs.get(i);
			config.setContext(interpreter.atn.getCachedContext(config.getContext()));
		}
	}

	clone(readonly: boolean): ATNConfigSet {
		let copy: ATNConfigSet =  new ATNConfigSet(this, readonly);
		if (!readonly && this.isReadOnly()) {
			copy.addAll(this.configs);
		}

		return copy;
	}

	@Override
	size(): number {
		return configs.size();
	}

	@Override
	isEmpty(): boolean {
		return configs.isEmpty();
	}

	@Override
	contains(o: any): boolean {
		if (!(o instanceof ATNConfig)) {
			return false;
		}

		let config: ATNConfig =  (ATNConfig)o;
		let configKey: number =  getKey(config);
		let mergedConfig: ATNConfig =  mergedConfigs.get(configKey);
		if (mergedConfig != null && canMerge(config, configKey, mergedConfig)) {
			return mergedConfig.contains(config);
		}

		for (let c of unmerged) {
			if (c.contains(config)) {
				return true;
			}
		}

		return false;
	}

	@Override
	iterator(): Iterator<ATNConfig> {
		return new ATNConfigSetIterator();
	}

	@Override
	toArray(): any[] {
		return configs.toArray();
	}

	@Override
	toArray<T>(a: T[]): T[] {
		return configs.toArray(a);
	}

	@Override
	add(e: ATNConfig): boolean {
		return add(e, null);
	}

	add(e: ATNConfig, @Nullable contextCache: PredictionContextCache): boolean {
		ensureWritable();
		assert(!outermostConfigSet || !e.getReachesIntoOuterContext());

		if (contextCache == null) {
			contextCache = PredictionContextCache.UNCACHED;
		}

		let addKey: boolean; 
		let key: number =  getKey(e);
		let mergedConfig: ATNConfig =  mergedConfigs.get(key);
		addKey = (mergedConfig == null);
		if (mergedConfig != null && canMerge(e, key, mergedConfig)) {
			mergedConfig.setOuterContextDepth(Math.max(mergedConfig.getOuterContextDepth(), e.getOuterContextDepth()));
			if (e.isPrecedenceFilterSuppressed()) {
				mergedConfig.setPrecedenceFilterSuppressed(true);
			}

			let joined: PredictionContext =  PredictionContext.join(mergedConfig.getContext(), e.getContext(), contextCache);
			updatePropertiesForMergedConfig(e);
			if (mergedConfig.getContext() == joined) {
				return false;
			}

			mergedConfig.setContext(joined);
			return true;
		}

		for (let i = 0; i < unmerged.size(); i++) {
			let unmergedConfig: ATNConfig =  unmerged.get(i);
			if (canMerge(e, key, unmergedConfig)) {
				unmergedConfig.setOuterContextDepth(Math.max(unmergedConfig.getOuterContextDepth(), e.getOuterContextDepth()));
				if (e.isPrecedenceFilterSuppressed()) {
					unmergedConfig.setPrecedenceFilterSuppressed(true);
				}

				let joined: PredictionContext =  PredictionContext.join(unmergedConfig.getContext(), e.getContext(), contextCache);
				updatePropertiesForMergedConfig(e);
				if (unmergedConfig.getContext() == joined) {
					return false;
				}

				unmergedConfig.setContext(joined);

				if (addKey) {
					mergedConfigs.put(key, unmergedConfig);
					unmerged.remove(i);
				}

				return true;
			}
		}

		configs.add(e);
		if (addKey) {
			mergedConfigs.put(key, e);
		} else {
			unmerged.add(e);
		}

		updatePropertiesForAddedConfig(e);
		return true;
	}

	private updatePropertiesForMergedConfig(config: ATNConfig): void {
		// merged configs can't change the alt or semantic context
		dipsIntoOuterContext |= config.getReachesIntoOuterContext();
		assert(!outermostConfigSet || !dipsIntoOuterContext);
	}

	private updatePropertiesForAddedConfig(config: ATNConfig): void {
		if (configs.size() == 1) {
			uniqueAlt = config.getAlt();
		} else if (uniqueAlt != config.getAlt()) {
			uniqueAlt = ATN.INVALID_ALT_NUMBER;
		}

		hasSemanticContext |= !SemanticContext.NONE.equals(config.getSemanticContext());
		dipsIntoOuterContext |= config.getReachesIntoOuterContext();
		assert(!outermostConfigSet || !dipsIntoOuterContext);
	}

	protected canMerge(left: ATNConfig, leftKey: number, right: ATNConfig): boolean {
		if (left.getState().stateNumber != right.getState().stateNumber) {
			return false;
		}

		if (leftKey != getKey(right)) {
			return false;
		}

		return left.getSemanticContext().equals(right.getSemanticContext());
	}

	protected getKey(e: ATNConfig): number {
		let key: number =  e.getState().stateNumber;
		key = (key << 12) | (e.getAlt() & 0xFFF);
		return key;
	}

	@Override
	remove(o: any): boolean {
		ensureWritable();

		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	containsAll(c: Collection<any>): boolean {
		for (let o of c) {
			if (!(o instanceof ATNConfig)) {
				return false;
			}

			if (!contains((ATNConfig)o)) {
				return false;
			}
		}

		return true;
	}

	@Override
	addAll(c: Collection<? extends ATNConfig>): boolean {
		return addAll(c, null);
	}

	addAll(c: Collection<? extends ATNConfig>, contextCache: PredictionContextCache): boolean {
		ensureWritable();

		let changed: boolean =  false;
		for (let group of c) {
			changed |= add(group, contextCache);
		}

		return changed;
	}

	@Override
	retainAll(c: Collection<any>): boolean {
		ensureWritable();
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	removeAll(c: Collection<any>): boolean {
		ensureWritable();
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	clear(): void {
		ensureWritable();

		mergedConfigs.clear();
		unmerged.clear();
		configs.clear();

		dipsIntoOuterContext = false;
		hasSemanticContext = false;
		uniqueAlt = ATN.INVALID_ALT_NUMBER;
		conflictInfo = null;
	}

	@Override
	equals(obj: any): boolean {
		if (this == obj) {
			return true;
		}

		if (!(obj instanceof ATNConfigSet)) {
			return false;
		}

		let other: ATNConfigSet =  (ATNConfigSet)obj;
		return this.outermostConfigSet == other.outermostConfigSet
			&& Utils.equals(conflictInfo, other.conflictInfo)
			&& configs.equals(other.configs);
	}

	@Override
	hashCode(): number {
		if (isReadOnly() && cachedHashCode != -1) {
			return cachedHashCode;
		}

		let hashCode: number =  1;
		hashCode = 5 * hashCode ^ (outermostConfigSet ? 1 : 0);
		hashCode = 5 * hashCode ^ configs.hashCode();

		if (isReadOnly()) {
			cachedHashCode = hashCode;
		}

		return hashCode;
	}

	@Override
	toString(): string {
		return toString(false);
	}

	toString(showContext: boolean): string {
		let buf: StringBuilder =  new StringBuilder();
		let sortedConfigs: List<ATNConfig> =  new ArrayList<ATNConfig>(configs);
		Collections.sort(sortedConfigs, new Comparator<ATNConfig>() {
			@Override
			compare(o1: ATNConfig, o2: ATNConfig): number {
				if (o1.getAlt() != o2.getAlt()) {
					return o1.getAlt() - o2.getAlt();
				}
				else if (o1.getState().stateNumber != o2.getState().stateNumber) {
					return o1.getState().stateNumber - o2.getState().stateNumber;
				}
				else {
					return o1.getSemanticContext().toString().compareTo(o2.getSemanticContext().toString());
				}
			}
		});

		buf.append("[");
		for (let i = 0; i < sortedConfigs.size(); i++) {
			if (i > 0) {
				buf.append(", ");
			}
			buf.append(sortedConfigs.get(i).toString(null, true, showContext));
		}
		buf.append("]");

		if ( hasSemanticContext ) buf.append(",hasSemanticContext=").append(hasSemanticContext);
		if ( uniqueAlt!=ATN.INVALID_ALT_NUMBER ) buf.append(",uniqueAlt=").append(uniqueAlt);
		if ( conflictInfo!=null ) {
			buf.append(",conflictingAlts=").append(conflictInfo.getConflictedAlts());
			if (!conflictInfo.isExact()) {
				buf.append("*");
			}
		}
		if ( dipsIntoOuterContext ) buf.append(",dipsIntoOuterContext");
		return buf.toString();
	}

	getUniqueAlt(): number {
		return uniqueAlt;
	}

	hasSemanticContext(): boolean {
		return hasSemanticContext;
	}

	clearExplicitSemanticContext(): void {
		ensureWritable();
		hasSemanticContext = false;
	}

	markExplicitSemanticContext(): void {
		ensureWritable();
		hasSemanticContext = true;
	}

	getConflictInfo(): ConflictInfo {
		return conflictInfo;
	}

	setConflictInfo(conflictInfo: ConflictInfo): void {
		ensureWritable();
		this.conflictInfo = conflictInfo;
	}

	getConflictingAlts(): BitSet {
		if (conflictInfo == null) {
			return null;
		}

		return conflictInfo.getConflictedAlts();
	}

	isExactConflict(): boolean {
		if (conflictInfo == null) {
			return false;
		}

		return conflictInfo.isExact();
	}

	getDipsIntoOuterContext(): boolean {
		return dipsIntoOuterContext;
	}

	get(index: number): ATNConfig {
		return configs.get(index);
	}

	remove(index: number): void {
		ensureWritable();
		let config: ATNConfig =  configs.get(index);
		configs.remove(config);
		let key: number =  getKey(config);
		if (mergedConfigs.get(key) == config) {
			mergedConfigs.remove(key);
		} else {
			for (let i = 0; i < unmerged.size(); i++) {
				if (unmerged.get(i) == config) {
					unmerged.remove(i);
					return;
				}
			}
		}
	}

	protected ensureWritable(): void {
		if (isReadOnly()) {
			throw new IllegalStateException("This ATNConfigSet is read only.");
		}
	}

	private final class ATNConfigSetIterator implements Iterator<ATNConfig> {

		let index: number =  -1;
		let removed: boolean =  false;

		@Override
		hasNext(): boolean {
			return index + 1 < configs.size();
		}

		@Override
		next(): ATNConfig {
			if (!hasNext()) {
				throw new NoSuchElementException();
			}

			index++;
			removed = false;
			return configs.get(index);
		}

		@Override
		remove(): void {
			if (removed || index < 0 || index >= configs.size()) {
				throw new IllegalStateException();
			}

			ATNConfigSet.this.remove(index);
			removed = true;
		}

	}
}
