/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:25.2796692-07:00

/** A tuple: (ATN state, predicted alt, syntactic, semantic context).
 *  The syntactic context is a graph-structured stack node whose
 *  path(s) to the root is the rule invocation(s)
 *  chain used to arrive at the state.  The semantic context is
 *  the tree of semantic predicates encountered before reaching
 *  an ATN state.
 */
export class ATNConfig {
	/**
	 * This field stores the bit mask for implementing the
	 * {@link #isPrecedenceFilterSuppressed} property as a bit within the
	 * existing {@link #altAndOuterContextDepth} field.
	 */
	private static SUPPRESS_PRECEDENCE_FILTER: number =  0x80000000;

	/** The ATN state associated with this configuration */
	@NotNull
	private state: ATNState; 

	/**
	 * This is a bit-field currently containing the following values.
	 *
	 * <ul>
	 * <li>0x00FFFFFF: Alternative</li>
	 * <li>0x7F000000: Outer context depth</li>
	 * <li>0x80000000: Suppress precedence filter</li>
	 * </ul>
	 */
	private altAndOuterContextDepth: number; 

	/** The stack of invoking states leading to the rule/states associated
	 *  with this config.  We track only those contexts pushed during
	 *  execution of the ATN simulator.
	 */
	@NotNull
	private context: PredictionContext; 

	 constructor(@NotNull state: ATNState, 
						alt: number,
						@NotNull context: PredictionContext) 
	{
		assert((alt & 0xFFFFFF) == alt);
		this.state = state;
		this.altAndOuterContextDepth = alt;
		this.context = context;
	}

	 constructor1(@NotNull c: ATNConfig, @NotNull state: ATNState, @NotNull context: PredictionContext) 
    {
		this.state = state;
		this.altAndOuterContextDepth = c.altAndOuterContextDepth;
		this.context = context;
	}

	static create(@NotNull state: ATNState, alt: number, @Nullable context: PredictionContext): ATNConfig {
		return create(state, alt, context, SemanticContext.NONE, null);
	}

	static create(@NotNull state: ATNState, alt: number, @Nullable context: PredictionContext, @NotNull semanticContext: SemanticContext): ATNConfig {
		return create(state, alt, context, semanticContext, null);
	}

	static create(@NotNull state: ATNState, alt: number, @Nullable context: PredictionContext, @NotNull semanticContext: SemanticContext, lexerActionExecutor: LexerActionExecutor): ATNConfig {
		if (semanticContext != SemanticContext.NONE) {
			if (lexerActionExecutor != null) {
				return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
			}
			else {
				return new SemanticContextATNConfig(semanticContext, state, alt, context);
			}
		}
		else if (lexerActionExecutor != null) {
			return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
		}
		else {
			return new ATNConfig(state, alt, context);
		}
	}

	/** Gets the ATN state associated with this configuration */
	@NotNull
	getState(): ATNState {
		return state;
	}

	/** What alt (or lexer rule) is predicted by this configuration */
	getAlt(): number {
		return altAndOuterContextDepth & 0x00FFFFFF;
	}

	@NotNull
	getContext(): PredictionContext {
		return context;
	}

	setContext(@NotNull context: PredictionContext): void {
		this.context = context;
	}

	getReachesIntoOuterContext(): boolean {
		return getOuterContextDepth() != 0;
	}

	/**
	 * We cannot execute predicates dependent upon local context unless
	 * we know for sure we are in the correct context. Because there is
	 * no way to do this efficiently, we simply cannot evaluate
	 * dependent predicates unless we are in the rule that initially
	 * invokes the ATN simulator.
	 *
	 * <p>
	 * closure() tracks the depth of how far we dip into the outer context:
	 * depth &gt; 0.  Note that it may not be totally accurate depth since I
	 * don't ever decrement. TODO: make it a boolean then</p>
	 */
	getOuterContextDepth(): number {
		return (altAndOuterContextDepth >>> 24) & 0x7F;
	}

	setOuterContextDepth(outerContextDepth: number): void {
		assert(outerContextDepth >= 0);
		// saturate at 0x7F - everything but zero/positive is only used for debug information anyway
		outerContextDepth = Math.min(outerContextDepth, 0x7F);
		this.altAndOuterContextDepth = (outerContextDepth << 24) | (altAndOuterContextDepth & ~0x7F000000);
	}

	@Nullable
	getLexerActionExecutor(): LexerActionExecutor {
		return null;
	}

	@NotNull
	getSemanticContext(): SemanticContext {
		return SemanticContext.NONE;
	}

	hasPassedThroughNonGreedyDecision(): boolean {
		return false;
	}

	@Override
	clone(): ATNConfig {
		return transform(this.getState(), false);
	}

	transform(@NotNull state: ATNState, checkNonGreedy: boolean): ATNConfig {
		return transform(state, this.context, this.getSemanticContext(), checkNonGreedy, this.getLexerActionExecutor());
	}

	transform(@NotNull state: ATNState, @NotNull semanticContext: SemanticContext, checkNonGreedy: boolean): ATNConfig {
		return transform(state, this.context, semanticContext, checkNonGreedy, this.getLexerActionExecutor());
	}

	transform(@NotNull state: ATNState, @Nullable context: PredictionContext, checkNonGreedy: boolean): ATNConfig {
		return transform(state, context, this.getSemanticContext(), checkNonGreedy, this.getLexerActionExecutor());
	}

	transform(@NotNull state: ATNState, lexerActionExecutor: LexerActionExecutor, checkNonGreedy: boolean): ATNConfig {
		return transform(state, context, this.getSemanticContext(), checkNonGreedy, lexerActionExecutor);
	}

	private transform(@NotNull state: ATNState, @Nullable context: PredictionContext, @NotNull semanticContext: SemanticContext, checkNonGreedy: boolean, lexerActionExecutor: LexerActionExecutor): ATNConfig {
		let passedThroughNonGreedy: boolean =  checkNonGreedy && checkNonGreedyDecision(this, state);
		if (semanticContext != SemanticContext.NONE) {
			if (lexerActionExecutor != null || passedThroughNonGreedy) {
				return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, this, state, context, passedThroughNonGreedy);
			}
			else {
				return new SemanticContextATNConfig(semanticContext, this, state, context);
			}
		}
		else if (lexerActionExecutor != null || passedThroughNonGreedy) {
			return new ActionATNConfig(lexerActionExecutor, this, state, context, passedThroughNonGreedy);
		}
		else {
			return new ATNConfig(this, state, context);
		}
	}

	private static checkNonGreedyDecision(source: ATNConfig, target: ATNState): boolean {
		return source.hasPassedThroughNonGreedyDecision()
			|| target instanceof DecisionState && ((DecisionState)target).nonGreedy;
	}

	appendContext(context: number, contextCache: PredictionContextCache): ATNConfig {
		let appendedContext: PredictionContext =  getContext().appendContext(context, contextCache);
		let result: ATNConfig =  transform(getState(), appendedContext, false);
		return result;
	}

	appendContext(context: PredictionContext, contextCache: PredictionContextCache): ATNConfig {
		let appendedContext: PredictionContext =  getContext().appendContext(context, contextCache);
		let result: ATNConfig =  transform(getState(), appendedContext, false);
		return result;
	}

	contains(subconfig: ATNConfig): boolean {
		if (this.getState().stateNumber != subconfig.getState().stateNumber
			|| this.getAlt() != subconfig.getAlt()
			|| !this.getSemanticContext().equals(subconfig.getSemanticContext())) {
			return false;
		}

		let leftWorkList: Deque<PredictionContext> =  new ArrayDeque<PredictionContext>();
		let rightWorkList: Deque<PredictionContext> =  new ArrayDeque<PredictionContext>();
		leftWorkList.add(getContext());
		rightWorkList.add(subconfig.getContext());
		while (!leftWorkList.isEmpty()) {
			let left: PredictionContext =  leftWorkList.pop();
			let right: PredictionContext =  rightWorkList.pop();

			if (left == right) {
				return true;
			}

			if (left.size() < right.size()) {
				return false;
			}

			if (right.isEmpty()) {
				return left.hasEmpty();
			} else {
				for (let i = 0; i < right.size(); i++) {
					let index: number =  left.findReturnState(right.getReturnState(i));
					if (index < 0) {
						// assumes invokingStates has no duplicate entries
						return false;
					}

					leftWorkList.push(left.getParent(index));
					rightWorkList.push(right.getParent(i));
				}
			}
		}

		return false;
	}

	isPrecedenceFilterSuppressed(): boolean {
		return (altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) != 0;
	}

	setPrecedenceFilterSuppressed(value: boolean): void {
		if (value) {
			this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
		}
		else {
			this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
		}
	}

	/** An ATN configuration is equal to another if both have
     *  the same state, they predict the same alternative, and
     *  syntactic/semantic contexts are the same.
     */
    @Override
    equals(o: any): boolean {
		if (!(o instanceof ATNConfig)) {
			return false;
		}

		return this.equals((ATNConfig)o);
	}

	equals(other: ATNConfig): boolean {
		if (this == other) {
			return true;
		} else if (other == null) {
			return false;
		}

		return this.getState().stateNumber==other.getState().stateNumber
			&& this.getAlt()==other.getAlt()
			&& this.getReachesIntoOuterContext() == other.getReachesIntoOuterContext()
			&& this.getContext().equals(other.getContext())
			&& this.getSemanticContext().equals(other.getSemanticContext())
			&& this.isPrecedenceFilterSuppressed() == other.isPrecedenceFilterSuppressed()
			&& this.hasPassedThroughNonGreedyDecision() == other.hasPassedThroughNonGreedyDecision()
			&& ObjectEqualityComparator.INSTANCE.equals(this.getLexerActionExecutor(), other.getLexerActionExecutor());
	}

	@Override
	hashCode(): number {
		let hashCode: number =  MurmurHash.initialize(7);
		hashCode = MurmurHash.update(hashCode, getState().stateNumber);
		hashCode = MurmurHash.update(hashCode, getAlt());
		hashCode = MurmurHash.update(hashCode, getReachesIntoOuterContext() ? 1 : 0);
		hashCode = MurmurHash.update(hashCode, getContext());
		hashCode = MurmurHash.update(hashCode, getSemanticContext());
		hashCode = MurmurHash.update(hashCode, hasPassedThroughNonGreedyDecision() ? 1 : 0);
		hashCode = MurmurHash.update(hashCode, getLexerActionExecutor());
		hashCode = MurmurHash.finish(hashCode, 7);
        return hashCode;
    }

	toDotString(): string {
		let builder: StringBuilder =  new StringBuilder();
		builder.append("digraph G {\n");
		builder.append("rankdir=LR;\n");

		let visited: Map<PredictionContext, PredictionContext> =  new IdentityHashMap<PredictionContext, PredictionContext>();
		let workList: Deque<PredictionContext> =  new ArrayDeque<PredictionContext>();
		workList.add(getContext());
		visited.put(getContext(), getContext());
		while (!workList.isEmpty()) {
			let current: PredictionContext =  workList.pop();
			for (let i = 0; i < current.size(); i++) {
				builder.append("  s").append(System.identityHashCode(current));
				builder.append("->");
				builder.append("s").append(System.identityHashCode(current.getParent(i)));
				builder.append("[label=\"").append(current.getReturnState(i)).append("\"];\n");
				if (visited.put(current.getParent(i), current.getParent(i)) == null) {
					workList.push(current.getParent(i));
				}
			}
		}

		builder.append("}\n");
		return builder.toString();
	}

	@Override
	toString(): string {
		return toString(null, true, false);
	}

	toString(@Nullable recog: Recognizer<any,any>, showAlt: boolean): string {
		return toString(recog, showAlt, true);
	}

	toString(@Nullable recog: Recognizer<any,any>, showAlt: boolean, showContext: boolean): string {
		let buf: StringBuilder =  new StringBuilder();
//		if ( state.ruleIndex>=0 ) {
//			if ( recog!=null ) buf.append(recog.getRuleNames()[state.ruleIndex]+":");
//			else buf.append(state.ruleIndex+":");
//		}
		let contexts: string[]; 
		if (showContext) {
			contexts = getContext().toStrings(recog, this.getState().stateNumber);
		}
		else {
			contexts = new String[] { "?" };
		}
		let first: boolean =  true;
		for (let contextDesc of contexts) {
			if ( first ) {
				first = false;
			}
			else {
				buf.append(", ");
			}

			buf.append('(');
			buf.append(getState());
			if ( showAlt ) {
				buf.append(",");
				buf.append(getAlt());
			}
			if ( getContext()!=null ) {
				buf.append(",");
				buf.append(contextDesc);
			}
			if ( getSemanticContext()!=null && getSemanticContext() != SemanticContext.NONE ) {
				buf.append(",");
				buf.append(getSemanticContext());
			}
			if ( getReachesIntoOuterContext() ) {
				buf.append(",up=").append(getOuterContextDepth());
			}
			buf.append(')');
		}
		return buf.toString();
    }

	private static class SemanticContextATNConfig extends ATNConfig {

		@NotNull
		private semanticContext: SemanticContext; 

		public SemanticContextATNConfig(SemanticContext semanticContext, @NotNull ATNState state, int alt, @Nullable PredictionContext context) {
			super(state, alt, context);
			this.semanticContext = semanticContext;
		}

		public SemanticContextATNConfig(SemanticContext semanticContext, @NotNull ATNConfig c, @NotNull ATNState state, @Nullable PredictionContext context) {
			super(c, state, context);
			this.semanticContext = semanticContext;
		}

		@Override
		getSemanticContext(): SemanticContext {
			return semanticContext;
		}

	}

	private static class ActionATNConfig extends ATNConfig {

		private lexerActionExecutor: LexerActionExecutor; 
		private passedThroughNonGreedyDecision: boolean; 

		public ActionATNConfig(LexerActionExecutor lexerActionExecutor, @NotNull ATNState state, int alt, @Nullable PredictionContext context, boolean passedThroughNonGreedyDecision) {
			super(state, alt, context);
			this.lexerActionExecutor = lexerActionExecutor;
			this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
		}

		protected ActionATNConfig(LexerActionExecutor lexerActionExecutor, @NotNull ATNConfig c, @NotNull ATNState state, @Nullable PredictionContext context, boolean passedThroughNonGreedyDecision) {
			super(c, state, context);
			if (c.getSemanticContext() != SemanticContext.NONE) {
				throw new UnsupportedOperationException();
			}

			this.lexerActionExecutor = lexerActionExecutor;
			this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
		}

		@Override
		getLexerActionExecutor(): LexerActionExecutor {
			return lexerActionExecutor;
		}

		@Override
		hasPassedThroughNonGreedyDecision(): boolean {
			return passedThroughNonGreedyDecision;
		}
	}

	private static class ActionSemanticContextATNConfig extends SemanticContextATNConfig {

		private lexerActionExecutor: LexerActionExecutor; 
		private passedThroughNonGreedyDecision: boolean; 

		public ActionSemanticContextATNConfig(LexerActionExecutor lexerActionExecutor, @NotNull SemanticContext semanticContext, @NotNull ATNState state, int alt, @Nullable PredictionContext context, boolean passedThroughNonGreedyDecision) {
			super(semanticContext, state, alt, context);
			this.lexerActionExecutor = lexerActionExecutor;
			this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
		}

		public ActionSemanticContextATNConfig(LexerActionExecutor lexerActionExecutor, @NotNull SemanticContext semanticContext, @NotNull ATNConfig c, @NotNull ATNState state, @Nullable PredictionContext context, boolean passedThroughNonGreedyDecision) {
			super(semanticContext, c, state, context);
			this.lexerActionExecutor = lexerActionExecutor;
			this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
		}

		@Override
		getLexerActionExecutor(): LexerActionExecutor {
			return lexerActionExecutor;
		}

		@Override
		hasPassedThroughNonGreedyDecision(): boolean {
			return passedThroughNonGreedyDecision;
		}
	}

}
