/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:35.6390614-07:00

/** Used to cache {@link PredictionContext} objects. Its used for the shared
 *  context cash associated with contexts in DFA states. This cache
 *  can be used for both lexers and parsers.
 *
 * @author Sam Harwell
 */
export class PredictionContextCache {
    static UNCACHED: PredictionContextCache =  new PredictionContextCache(false);

    private contexts: Map<PredictionContext, PredictionContext> = 
        new HashMap<PredictionContext, PredictionContext>();
    private childContexts: Map<PredictionContextAndnumber, PredictionContext> = 
        new HashMap<PredictionContextAndInt, PredictionContext>();
    private joinContexts: Map<IdentityCommutativePredictionContextOperands, PredictionContext> = 
        new HashMap<IdentityCommutativePredictionContextOperands, PredictionContext>();

    private enableCache: boolean; 

     constructor()  {
        this(true);
    }

     constructor1(enableCache: boolean)  {
        this.enableCache = enableCache;
    }

    getAsCached(context: PredictionContext): PredictionContext {
        if (!enableCache) {
            return context;
        }

        let result: PredictionContext =  contexts.get(context);
        if (result == null) {
            result = context;
            contexts.put(context, context);
        }

        return result;
    }

    getChild(context: PredictionContext, invokingState: number): PredictionContext {
        if (!enableCache) {
            return context.getChild(invokingState);
        }

        let operands: PredictionContextAndnumber =  new PredictionContextAndInt(context, invokingState);
        let result: PredictionContext =  childContexts.get(operands);
        if (result == null) {
            result = context.getChild(invokingState);
            result = getAsCached(result);
            childContexts.put(operands, result);
        }

        return result;
    }

    join(x: PredictionContext, y: PredictionContext): PredictionContext {
        if (!enableCache) {
            return PredictionContext.join(x, y, this);
        }

        let operands: IdentityCommutativePredictionContextOperands =  new IdentityCommutativePredictionContextOperands(x, y);
        let result: PredictionContext =  joinContexts.get(operands);
        if (result != null) {
            return result;
        }

        result = PredictionContext.join(x, y, this);
        result = getAsCached(result);
        joinContexts.put(operands, result);
        return result;
    }

    protected static final class PredictionContextAndInt {
        private obj: PredictionContext; 
        private value: number; 

        public PredictionContextAndInt(PredictionContext obj, int value) {
            this.obj = obj;
            this.value = value;
        }

        @Override
        equals(obj: any): boolean {
            if (!(obj instanceof PredictionContextAndInt)) {
                return false;
            } else if (obj == this) {
                return true;
            }

            let other: PredictionContextAndnumber =  (PredictionContextAndInt)obj;
            return this.value == other.value
                && (this.obj == other.obj || (this.obj != null && this.obj.equals(other.obj)));
        }

        @Override
        hashCode(): number {
            let hashCode: number =  5;
            hashCode = 7 * hashCode + (obj != null ? obj.hashCode() : 0);
            hashCode = 7 * hashCode + value;
            return hashCode;
        }
    }

    protected static final class IdentityCommutativePredictionContextOperands {

        private x: PredictionContext; 
        private y: PredictionContext; 

        public IdentityCommutativePredictionContextOperands(PredictionContext x, PredictionContext y) {
            this.x = x;
            this.y = y;
        }

        getX(): PredictionContext {
            return x;
        }

        getY(): PredictionContext {
            return y;
        }

        @Override
        equals(obj: any): boolean {
            if (!(obj instanceof IdentityCommutativePredictionContextOperands)) {
                return false;
            }
            else if (this == obj) {
                return true;
            }

            let other: IdentityCommutativePredictionContextOperands =  (IdentityCommutativePredictionContextOperands)obj;
            return (this.x == other.x && this.y == other.y) || (this.x == other.y && this.y == other.x);
        }

        @Override
        hashCode(): number {
            return x.hashCode() ^ y.hashCode();
        }
    }

}
