/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:36.9521478-07:00

/** A tree structure used to record the semantic context in which
 *  an ATN configuration is valid.  It's either a single predicate,
 *  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 *  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 *  {@link SemanticContext} within the scope of this outer class.</p>
 */
export abstract class SemanticContext {
	/**
	 * The default {@link SemanticContext}, which is semantically equivalent to
	 * a predicate of the form {@code {true}?}.
	 */
    static NONE: SemanticContext =  new Predicate();

	/**
	 * For context independent predicates, we evaluate them without a local
	 * context (i.e., null context). That way, we can evaluate them without
	 * having to create proper rule-specific context during prediction (as
	 * opposed to the parser, which creates them naturally). In a practical
	 * sense, this avoids a cast exception from RuleContext to myruleContext.
	 *
	 * <p>For context dependent predicates, we must pass in a local context so that
	 * references such as $arg evaluate properly as _localctx.arg. We only
	 * capture context dependent predicates in the context in which we begin
	 * prediction, so we passed in the outer context here in case of context
	 * dependent predicate evaluation.</p>
	 */
    abstract eval<T>(parser: Recognizer<T,any>, parserCallStack: RuleContext): boolean;

	/**
	 * Evaluate the precedence predicates for the context and reduce the result.
	 *
	 * @param parser The parser instance.
	 * @param parserCallStack
	 * @return The simplified semantic context after precedence predicates are
	 * evaluated, which will be one of the following values.
	 * <ul>
	 * <li>{@link #NONE}: if the predicate simplifies to {@code true} after
	 * precedence predicates are evaluated.</li>
	 * <li>{@code null}: if the predicate simplifies to {@code false} after
	 * precedence predicates are evaluated.</li>
	 * <li>{@code this}: if the semantic context is not changed as a result of
	 * precedence predicate evaluation.</li>
	 * <li>A non-{@code null} {@link SemanticContext}: the new simplified
	 * semantic context after precedence predicates are evaluated.</li>
	 * </ul>
	 */
	evalPrecedence(parser: Recognizer<any,any>, parserCallStack: RuleContext): SemanticContext {
		return this;
	}

    public static class Predicate extends SemanticContext {
        ruleIndex: number; 
       	predIndex: number; 
       	isCtxDependent: boolean;   // e.g., $i ref in pred

        protected Predicate() {
            this.ruleIndex = -1;
            this.predIndex = -1;
            this.isCtxDependent = false;
        }

        public Predicate(int ruleIndex, int predIndex, boolean isCtxDependent) {
            this.ruleIndex = ruleIndex;
            this.predIndex = predIndex;
            this.isCtxDependent = isCtxDependent;
        }

        @Override
        eval<T>(parser: Recognizer<T,any>, parserCallStack: RuleContext): boolean {
            let localctx: RuleContext =  isCtxDependent ? parserCallStack : null;
            return parser.sempred(localctx, ruleIndex, predIndex);
        }

		@Override
		hashCode(): number {
			let hashCode: number =  MurmurHash.initialize();
			hashCode = MurmurHash.update(hashCode, ruleIndex);
			hashCode = MurmurHash.update(hashCode, predIndex);
			hashCode = MurmurHash.update(hashCode, isCtxDependent ? 1 : 0);
			hashCode = MurmurHash.finish(hashCode, 3);
			return hashCode;
		}

		@Override
		equals(obj: any): boolean {
			if ( !(obj instanceof Predicate) ) return false;
			if ( this == obj ) return true;
			let p: Predicate =  (Predicate)obj;
			return this.ruleIndex == p.ruleIndex &&
				   this.predIndex == p.predIndex &&
				   this.isCtxDependent == p.isCtxDependent;
		}

		@Override
		toString(): string {
            return "{"+ruleIndex+":"+predIndex+"}?";
        }
    }

	public static class PrecedencePredicate extends SemanticContext implements Comparable<PrecedencePredicate> {
		precedence: number; 

		protected PrecedencePredicate() {
			this.precedence = 0;
		}

		public PrecedencePredicate(int precedence) {
			this.precedence = precedence;
		}

		@Override
		eval<T>(parser: Recognizer<T,any>, parserCallStack: RuleContext): boolean {
			return parser.precpred(parserCallStack, precedence);
		}

		@Override
		evalPrecedence(parser: Recognizer<any,any>, parserCallStack: RuleContext): SemanticContext {
			if (parser.precpred(parserCallStack, precedence)) {
				return SemanticContext.NONE;
			}
			else {
				return null;
			}
		}

		@Override
		compareTo(o: PrecedencePredicate): number {
			return precedence - o.precedence;
		}

		@Override
		hashCode(): number {
			let hashCode: number =  1;
			hashCode = 31 * hashCode + precedence;
			return hashCode;
		}

		@Override
		equals(obj: any): boolean {
			if (!(obj instanceof PrecedencePredicate)) {
				return false;
			}

			if (this == obj) {
				return true;
			}

			let other: PrecedencePredicate =  (PrecedencePredicate)obj;
			return this.precedence == other.precedence;
		}

		@Override
		// precedence >= _precedenceStack.peek()
		toString(): string {
			return "{"+precedence+">=prec}?";
		}
	}

	/**
	 * This is the base class for semantic context "operators", which operate on
	 * a collection of semantic context "operands".
	 *
	 * @since 4.3
	 */
	public static abstract class Operator extends SemanticContext {
		/**
		 * Gets the operands for the semantic context operator.
		 *
		 * @return a collection of {@link SemanticContext} operands for the
		 * operator.
		 *
		 * @since 4.3
		 */
		@NotNull
		abstract getOperands(): Collection<SemanticContext>;
	}

	/**
	 * A semantic context which is true whenever none of the contained contexts
	 * is false.
	 */
    public static class AND extends Operator {
		opnds: SemanticContext[]; 

		public AND(@NotNull SemanticContext a, @NotNull SemanticContext b) {
			let operands: Set<SemanticContext> =  new HashSet<SemanticContext>();
			if ( a instanceof AND ) operands.addAll(Arrays.asList(((AND)a).opnds));
			else operands.add(a);
			if ( b instanceof AND ) operands.addAll(Arrays.asList(((AND)b).opnds));
			else operands.add(b);

			let precedencePredicates: List<PrecedencePredicate> =  filterPrecedencePredicates(operands);
			if (!precedencePredicates.isEmpty()) {
				// interested in the transition with the lowest precedence
				let reduced: PrecedencePredicate =  Collections.min(precedencePredicates);
				operands.add(reduced);
			}

			opnds = operands.toArray(new SemanticContext[operands.size()]);
        }

		@Override
		getOperands(): Collection<SemanticContext> {
			return Arrays.asList(opnds);
		}

		@Override
		equals(obj: any): boolean {
			if ( this==obj ) return true;
			if ( !(obj instanceof AND) ) return false;
			let other: AND =  (AND)obj;
			return Arrays.equals(this.opnds, other.opnds);
		}

		@Override
		hashCode(): number {
			return MurmurHash.hashCode(opnds, AND.class.hashCode());
		}

		/**
		 * {@inheritDoc}
		 *
		 * <p>
		 * The evaluation of predicates by this context is short-circuiting, but
		 * unordered.</p>
		 */
		@Override
		eval<T>(parser: Recognizer<T,any>, parserCallStack: RuleContext): boolean {
			for (let opnd of opnds) {
				if ( !opnd.eval(parser, parserCallStack) ) return false;
			}
			return true;
        }

		@Override
		evalPrecedence(parser: Recognizer<any,any>, parserCallStack: RuleContext): SemanticContext {
			let differs: boolean =  false;
			let operands: List<SemanticContext> =  new ArrayList<SemanticContext>();
			for (let context of opnds) {
				let evaluated: SemanticContext =  context.evalPrecedence(parser, parserCallStack);
				differs |= (evaluated != context);
				if (evaluated == null) {
					// The AND context is false if any element is false
					return null;
				}
				else if (evaluated != NONE) {
					// Reduce the result by skipping true elements
					operands.add(evaluated);
				}
			}

			if (!differs) {
				return this;
			}

			if (operands.isEmpty()) {
				// all elements were true, so the AND context is true
				return NONE;
			}

			let result: SemanticContext =  operands.get(0);
			for (let i = 1; i < operands.size(); i++) {
				result = SemanticContext.and(result, operands.get(i));
			}

			return result;
		}

		@Override
		toString(): string {
			return Utils.join(opnds, "&&");
        }
    }

	/**
	 * A semantic context which is true whenever at least one of the contained
	 * contexts is true.
	 */
    public static class OR extends Operator {
		opnds: SemanticContext[]; 

		public OR(@NotNull SemanticContext a, @NotNull SemanticContext b) {
			let operands: Set<SemanticContext> =  new HashSet<SemanticContext>();
			if ( a instanceof OR ) operands.addAll(Arrays.asList(((OR)a).opnds));
			else operands.add(a);
			if ( b instanceof OR ) operands.addAll(Arrays.asList(((OR)b).opnds));
			else operands.add(b);

			let precedencePredicates: List<PrecedencePredicate> =  filterPrecedencePredicates(operands);
			if (!precedencePredicates.isEmpty()) {
				// interested in the transition with the highest precedence
				let reduced: PrecedencePredicate =  Collections.max(precedencePredicates);
				operands.add(reduced);
			}

			this.opnds = operands.toArray(new SemanticContext[operands.size()]);
        }

		@Override
		getOperands(): Collection<SemanticContext> {
			return Arrays.asList(opnds);
		}

		@Override
		equals(obj: any): boolean {
			if ( this==obj ) return true;
			if ( !(obj instanceof OR) ) return false;
			let other: OR =  (OR)obj;
			return Arrays.equals(this.opnds, other.opnds);
		}

		@Override
		hashCode(): number {
			return MurmurHash.hashCode(opnds, OR.class.hashCode());
		}

		/**
		 * {@inheritDoc}
		 *
		 * <p>
		 * The evaluation of predicates by this context is short-circuiting, but
		 * unordered.</p>
		 */
		@Override
        eval<T>(parser: Recognizer<T,any>, parserCallStack: RuleContext): boolean {
			for (let opnd of opnds) {
				if ( opnd.eval(parser, parserCallStack) ) return true;
			}
			return false;
        }

		@Override
		evalPrecedence(parser: Recognizer<any,any>, parserCallStack: RuleContext): SemanticContext {
			let differs: boolean =  false;
			let operands: List<SemanticContext> =  new ArrayList<SemanticContext>();
			for (let context of opnds) {
				let evaluated: SemanticContext =  context.evalPrecedence(parser, parserCallStack);
				differs |= (evaluated != context);
				if (evaluated == NONE) {
					// The OR context is true if any element is true
					return NONE;
				}
				else if (evaluated != null) {
					// Reduce the result by skipping false elements
					operands.add(evaluated);
				}
			}

			if (!differs) {
				return this;
			}

			if (operands.isEmpty()) {
				// all elements were false, so the OR context is false
				return null;
			}

			let result: SemanticContext =  operands.get(0);
			for (let i = 1; i < operands.size(); i++) {
				result = SemanticContext.or(result, operands.get(i));
			}

			return result;
		}

        @Override
        toString(): string {
			return Utils.join(opnds, "||");
        }
    }

	static and(a: SemanticContext, b: SemanticContext): SemanticContext {
		if ( a == null || a == NONE ) return b;
		if ( b == null || b == NONE ) return a;
		let result: AND =  new AND(a, b);
		if (result.opnds.length == 1) {
			return result.opnds[0];
		}

		return result;
	}

	/**
	 *
	 *  @see ParserATNSimulator#getPredsForAmbigAlts
	 */
	static or(a: SemanticContext, b: SemanticContext): SemanticContext {
		if ( a == null ) return b;
		if ( b == null ) return a;
		if ( a == NONE || b == NONE ) return NONE;
		let result: OR =  new OR(a, b);
		if (result.opnds.length == 1) {
			return result.opnds[0];
		}

		return result;
	}

	private static filterPrecedencePredicates(collection: Collection<? extends SemanticContext>): List<PrecedencePredicate> {
		let result: ArrayList<PrecedencePredicate> =  null;
		for (Iterator<? extends SemanticContext> iterator = collection.iterator(); iterator.hasNext(); ) {
			let context: SemanticContext =  iterator.next();
			if (context instanceof PrecedencePredicate) {
				if (result == null) {
					result = new ArrayList<PrecedencePredicate>();
				}

				result.add((PrecedencePredicate)context);
				iterator.remove();
			}
		}

		if (result == null) {
			return Collections.emptyList();
		}

		return result;
	}
}
