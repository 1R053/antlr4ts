/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ConvertTo-TS run at 2016-10-04T11:26:38.5097925-07:00

/** A DFA walker that knows how to dump them to serialized strings. */
export class DFASerializer {
	@NotNull
	private dfa: DFA; 
	@NotNull
	private vocabulary: Vocabulary; 
	@Nullable
	ruleNames: string[]; 
	@Nullable
	atn: ATN; 

	/**
	 * @deprecated Use {@link #DFASerializer(DFA, Vocabulary)} instead.
	 */
	@Deprecated
	 constructor(@NotNull dfa: DFA, @Nullable tokenNames: string[])  {
		this(dfa, VocabularyImpl.fromTokenNames(tokenNames), null, null);
	}

	 constructor1(@NotNull dfa: DFA, @NotNull vocabulary: Vocabulary)  {
		this(dfa, vocabulary, null, null);
	}

	 constructor2(@NotNull dfa: DFA, @Nullable parser: Recognizer<any,any>)  {
		this(dfa,
			 parser != null ? parser.getVocabulary() : VocabularyImpl.EMPTY_VOCABULARY,
			 parser != null ? parser.getRuleNames() : null,
			 parser != null ? parser.getATN() : null);
	}

	/**
	 * @deprecated Use {@link #DFASerializer(DFA, Vocabulary, String[], ATN)} instead.
	 */
	@Deprecated
	 constructor3(@NotNull dfa: DFA, @Nullable tokenNames: string[], @Nullable ruleNames: string[], @Nullable atn: ATN)  {
		this(dfa, VocabularyImpl.fromTokenNames(tokenNames), ruleNames, atn);
	}

	 constructor4(@NotNull dfa: DFA, @NotNull vocabulary: Vocabulary, @Nullable ruleNames: string[], @Nullable atn: ATN)  {
		this.dfa = dfa;
		this.vocabulary = vocabulary;
		this.ruleNames = ruleNames;
		this.atn = atn;
	}

	@Override
	toString(): string {
		if ( dfa.s0.get()==null ) return null;
		let buf: StringBuilder =  new StringBuilder();

		if ( dfa.states!=null ) {
			let states: List<DFAState> =  new ArrayList<DFAState>(dfa.states.values());
			Collections.sort(states, new Comparator<DFAState>(){

				@Override
				compare(o1: DFAState, o2: DFAState): number {
					return o1.stateNumber - o2.stateNumber;
				}
			});

			for (let s of states) {
				let edges: Map<number, DFAState> =  s.getEdgeMap();
				let contextEdges: Map<number, DFAState> =  s.getContextEdgeMap();
				for (Map.Entry<Integer, DFAState> entry : edges.entrySet()) {
					if ((entry.getValue() == null || entry.getValue() == ATNSimulator.ERROR) && !s.isContextSymbol(entry.getKey())) {
						continue;
					}

					let contextSymbol: boolean =  false;
					buf.append(getStateString(s)).append("-").append(getEdgeLabel(entry.getKey())).append("->");
					if (s.isContextSymbol(entry.getKey())) {
						buf.append("!");
						contextSymbol = true;
					}

					let t: DFAState =  entry.getValue();
					if ( t!=null && t.stateNumber != Integer.MAX_VALUE ) {
						buf.append(getStateString(t)).append('\n');
					}
					else if (contextSymbol) {
						buf.append("ctx\n");
					}
				}

				if (s.isContextSensitive()) {
					for (Map.Entry<Integer, DFAState> entry : contextEdges.entrySet()) {
						buf.append(getStateString(s))
							.append("-")
							.append(getContextLabel(entry.getKey()))
							.append("->")
							.append(getStateString(entry.getValue()))
							.append("\n");
					}
				}
			}
		}
		let output: string =  buf.toString();
		if ( output.length()==0 ) return null;
		//return Utils.sortLinesInString(output);
		return output;
	}

	protected getContextLabel(i: number): string {
		if (i == PredictionContext.EMPTY_FULL_STATE_KEY) {
			return "ctx:EMPTY_FULL";
		}
		else if (i == PredictionContext.EMPTY_LOCAL_STATE_KEY) {
			return "ctx:EMPTY_LOCAL";
		}

		if (atn != null && i > 0 && i <= atn.states.size()) {
			let state: ATNState =  atn.states.get(i);
			let ruleIndex: number =  state.ruleIndex;
			if (ruleNames != null && ruleIndex >= 0 && ruleIndex < ruleNames.length) {
				return "ctx:" + String.valueOf(i) + "(" + ruleNames[ruleIndex] + ")";
			}
		}

		return "ctx:" + String.valueOf(i);
	}

	protected getEdgeLabel(i: number): string {
		return vocabulary.getDisplayName(i);
	}

	getStateString(s: DFAState): string {
		if (s == ATNSimulator.ERROR) {
			return "ERROR";
		}

		let n: number =  s.stateNumber;
		let stateStr: string =  "s"+n;
		if ( s.isAcceptState() ) {
            if ( s.predicates!=null ) {
                stateStr = ":s"+n+"=>"+Arrays.toString(s.predicates);
            }
            else {
                stateStr = ":s"+n+"=>"+s.getPrediction();
            }
		}

		if ( s.isContextSensitive() ) {
			stateStr += "*";
			for (let config of s.configs) {
				if (config.getReachesIntoOuterContext()) {
					stateStr += "*";
					break;
				}
			}
		}
		return stateStr;
	}
}
